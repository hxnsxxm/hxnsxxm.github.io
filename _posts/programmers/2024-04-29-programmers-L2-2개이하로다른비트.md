---
title: "[Level 2] 2개 이하로 다른 비트, Java"
excerpt: "프로그래머스 레벨 2 : 2개 이하로 다른 비트 풀이 및 해설"

categories:
  - Programmers
tags:
  - [algorithm, programmers]

permalink: /algorithm/programmers/2개이하로다른비트

toc: true
toc_sticky: true

date: 2024-04-29
last_modified_at: 2024-04-29
---

## 문제

### 링크

[프로그래머스/2개 이하로 다른 비트](https://school.programmers.co.kr/learn/courses/30/lessons/77885)

<br>

### 문제 설명

양의 정수 `x`에 대한 함수 `f(x)`를 다음과 같이 정의합니다.

- `x`보다 크고 `x`와 **비트가 1~2개 다른** 수들 중에서 제일 작은 수

예를 들어,

- `f(2) = 3` 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

|수|비트|다른 비트의 개수|
|---|---|---|
|2|`000...0010`||
|3|`000...0011`|1|

- `f(7) = 11` 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

|수|비트|다른 비트의 개수|
|---|---|---|
|7|`000...0111`||
|8|`000...1000`|4|
|9|`000...1001`|3|
|10|`000...1010`|3|
|11|`000...1011`|2|

정수들이 담긴 배열 `numbers`가 매개변수로 주어집니다. `numbers`의 모든 수들에 대하여 각 수의 `f` 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

<br>

### 입력 & 출력

#### 제한사항

- 1 ≤ `numbers`의 길이 ≤ 100,000
- 0 ≤ `numbers`의 모든 수 ≤ 1015

#### 입출력 예

|numbers|result|
|---|---|
|`[2,7]`|`[3,11]`|

<br>

## 풀이

짝수와 홀수를 나눠서 고려해볼 수 있다.

그 이유는 비트로 생각해야 하기 때문인데, <b>짝수</b>인 경우 마지막 비트가 `0`이다. 그래서 조건을 맞추기 위해서
1만 더하면 된다.

| 수  | 비트               |
|----|------------------|
| 2  | `000...0010`     |
| 4  | `000...0100`     |
| 16 | `000...00010000` |

반면 <b>홀수</b>인 경우에는 마지막 비트가 `1`이다.
그래서 더 큰 수를 찾으려고 숫자를 더할 때, 올림수(carry)에 따른 상위 비트 변경을 고려해야 한다.

| 수  | 비트                |
|----|-------------------|
| 3  | `000...0011`      |
| 5  | `000...0101`      |
| 17 | `000...00010001` |

예를 들어서, 숫자 3은 1을 더하게 되면 `000...0100`이 되고, 숫자 5에 1을 더하면 `000...0110`이 된다.
상위비트가 `1`이냐 `0`이냐에 따라 달라지는 걸 생각해야 한다.

<br>

위의 상황과 조건을 만족하는 방법은 다음과 같다.

| 수  | 비트               |
|----|------------------|
| 31 | `000...00011111` |
| 32 | `000...00100000` |

숫자 a에 1을 더한 b가 있을 때, a와 b에 XOR 연산을 한다.
`0001 1111` XOR `0010 0000` = `0011 1111`.

이후 해당 값에 right shift 연산(>>)을 하고 b에 더한다.
`0011 1111` >> 2 = `0000 1111`, `0010 0000` + `0000 1111` = `0010 1111`

<br>

### 시간 복잡도

입력 `numbers`의 모든 원소를 한 번씩 반복하면서 위의 과정을 처리하면 되기 때문에 <b>O(n)</b>이다.

<br>

### 구현 코드

```java
package level2.몇개이하로다른비트;

public class solve_1st {
    class Solution {
        public long[] solution(long[] numbers) {
            long[] answer = numbers.clone();
            for (int i = 0; i < numbers.length; i++) {
                answer[i]++; // x보다 큰수로 만든다.
                answer[i] += (answer[i] ^ numbers[i]) >> 2;
            }
            return answer;
        }
    }
}
```


<hr>
<b>Reference</b>  
